% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_pch.R
\name{fit_pch}
\alias{fit_pch}
\alias{k_fit_pch}
\alias{fit_pch_robust}
\alias{fit_pch_subsample}
\title{Fit a polytope (Principal Convex Hull) to data using PCHA algorithm}
\usage{
fit_pch(data, noc = as.integer(3), I = NULL, U = NULL, delta = 0,
  verbose = FALSE, conv_crit = 1e-06, maxiter = 500,
  check_installed = T, order_by = seq(1, nrow(data)),
  order_by_side = TRUE)

k_fit_pch(data, ks = 2:4, check_installed = T, ...)

fit_pch_robust(data, n = 3, subsample = NULL, check_installed = T,
  type = c("s", "m", "cmq")[1], clust_options = list(), seed = 235,
  ...)

fit_pch_subsample(i = 1, data, subsample = NULL, ...)
}
\arguments{
\item{data}{numeric matrix in which to find archetypes, variables/dimentions in rows, examples in columns}

\item{noc}{integer, number of archetypes to find}

\item{I}{vector, entries of data to use for dictionary in C (optional)}

\item{U}{vector, entries of data to model in S (optional)}

\item{delta}{TO DO: find definition in matlab code}

\item{verbose}{if TRUE display messages}

\item{conv_crit}{The convergence criteria (default: 10^-6 relative change in SSE)}

\item{maxiter}{maximum number of iterations (default: 500 iterations)}

\item{check_installed}{if TRUE, check if python module py_pcha is found. Useful to set to FALSE for running analysis or within other functions}

\item{order_by}{integer, dimensions to be used for ordering vertices/archetypes. Vertices are ordered by angle (cosine) between c(1, 1) vector and a vector pointing to that vertex. Additional step finds when vertex vector is to the left (counter-clockwise) of the c(1, 1) vector.}

\item{order_by_side}{used for ordering. If TRUE use 2 dimentions, cosine distance to c(1,1) and measure to which side of the c(1,1) vector each vertex vector is located. If FALSE use more than 2 dimentions (provided via order_by) and use cosine distance to c(1,1, ..., 1) to order vertices.}

\item{ks}{integer vector, dimensions of polytopes to be fit to data}

\item{n}{number of samples that should be taken}

\item{subsample}{either NULL or the proportion of dataset that should be included in each sample. If NULL the polytope fitting algorithm is run n times which is usefult for evaluating how often the algorithm gets stuck in local optima}

\item{type}{one of s, m, cmq. s means single core processing using lapply. m means multi-core parallel procession using parLapply. cmq means multi-node parallel processing on a computing cluster using clustermq package. "See also" for details.}

\item{clust_options}{list of options for parallel processing. The default for "m" is list(cores = parallel::detectCores()-1, cluster_type = "PSOCK"). The default for "cmq" is list(memory = 2000, template = list(), n_jobs = 10, fail_on_error = FALSE). Change these options as required.}

\item{seed}{seed for reproducible random number generation. Works for all types of processing.}

\item{i}{iteration number}
}
\value{
\code{fit_pch()} object of class pch_fit (list) containing the following elements:
XC - numeric matrix, dim(I, noc)/dim(dimensions, archetypes) feature matrix (i.e. XC=data[,I]*C forming the archetypes);
S - numeric matrix, dim(noc, length(U)) matrix, S>=0 |S_j|_1=1;
C - numeric matrix, dim(noc, length(U)) matrix, S>=0 |S_j|_1=1;
SSE - numeric vector (1L), Sum of Squared Errors;
varexpl - numeric vector (1L), Percent variation explained by the model.

\code{k_fit_pch()} object of class k_pch_fit (list) containing XC (list of length(ks), individual XC matrices), S (list of length(ks), individual S matrices),  C (list of length(ks), individual C matrices), SSE (vector, length(ks)); varexpl - (vector, length(ks)). When length(ks) = 1 returns pch_fit.

\code{fit_pch_robust()} object of class r_pch_fit (list) containing XC (list of length n, individual XC matrices), S (list of length n, individual S matrices),  C (list of length n, individual C matrices), SSE (vector, length n); varexpl - (vector, length n).

\code{fit_pch_subsample()} object of class pch_fit (list)
}
\description{
\code{fit_pch()} fits a polytope (Principal Convex Hull) to data using PCHA algorithm. All of the listed functions take input matrix dim(variables/dimentions, examples) and return output (XC) of dim(variables/dimentions, archetypes).

\code{k_fit_pch()} finds polytopes of k dimensions in the data. This function applies \code{fit_pch()} to different k-s.

\code{fit_pch_robust()} subsamples the data to find robust positions of vertices of a polytope (Principal Convex Hull) to data. This function uses \code{fit_pch_subsample()}.

\code{fit_pch_subsample()} takes one subsample of the data and fits a polytope (Principal Convex Hull) to data. This function uses \code{fit_pch()}.
}
\details{
\code{fit_pch()} provides an R interface to python implementation of PCHA algorithm (Principal Convex Hull Analysis) by Ulf Aslak (https://github.com/ulfaslak/py_pcha) which was originally developed for Archetypal Analysis by MÃ¸rup et. al.
}
\examples{
set.seed(4355)
archetypes = generate_arc(arc_coord = list(c(5, 0), c(-10, 15), c(-30, -20)),
                          mean = 0, sd = 1, N_dim = 2)
data = generate_data(archetypes, N_examples = 1e4, jiiter = 0.04, size = 0.9)
dim(data)
# Fit a polytope with 3 vertices to data matrix
arc = fit_pch(data, noc=as.integer(3), delta=0.1)
# Fit the same polytope 3 times without subsampling to test convergence of the algorithm.
arc_rob = fit_pch_robust(data, n = 3, subsample = NULL,
                         noc=as.integer(3), delta=0.1)
# Fit the 10 polytopes to subsampled datasets each time looking at 70\% of examples.
arc_data = fit_pch_robust(data, n = 10, subsample = 0.7,
                         noc=as.integer(3), delta=0.1)

# Use local parallel processing to fit the 10 polytopes to subsampled datasets each time looking at 70\% of examples.
arc_data = fit_pch_robust(data, n = 10, subsample = 0.7,
                         noc=as.integer(3), delta=0.1, type = "m")

# Fit polytopes with 2-4 vertices
arc_ks = k_fit_pch(data, ks = 2:4, check_installed = T, delta=0.1)
}
\seealso{
\code{\link[parallel]{parLapply}}, \code{\link[base]{lapply}}, \code{\link[clustermq]{Q}}
}
\author{
Vitalii Kleshchevnikov
}
