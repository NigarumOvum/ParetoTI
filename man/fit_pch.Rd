% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_pch.R
\name{fit_pch}
\alias{fit_pch}
\alias{k_fit_pch}
\alias{fit_pch_bootstrap}
\alias{fit_pch_resample}
\alias{randomise_fit_pch1}
\title{Fit a polytope (Principal Convex Hull) to data using PCHA algorithm}
\usage{
fit_pch(data, noc = as.integer(3), I = NULL, U = NULL, delta = 0,
  verbose = FALSE, conv_crit = 1e-06, maxiter = 500,
  check_installed = T, order_by = seq(1, nrow(data)),
  order_by_side = TRUE)

k_fit_pch(data, ks = 2:4, check_installed = T, ...)

fit_pch_bootstrap(data, n = 3, sample_prop = NULL,
  check_installed = T, type = c("s", "m", "cmq")[1],
  clust_options = list(), seed = 235, replace = FALSE,
  sample_type = c("resample", "rand_shape")[1], ...)

fit_pch_resample(i = 1, data, sample_prop = NULL, replace = FALSE,
  sample_type = c("resample", "rand_shape")[1], ...)

randomise_fit_pch1(i = 1, data, true_fit = NULL, replace = FALSE,
  prob = NULL, bootstrap_N = 0, bootstrap_seed = NULL,
  return_data = FALSE, return_arc = FALSE, ...)
}
\arguments{
\item{data}{numeric matrix in which to find archetypes, variables/dimentions in rows, examples in columns}

\item{noc}{integer, number of archetypes to find}

\item{I}{vector, entries of data to use for dictionary in C (optional)}

\item{U}{vector, entries of data to model in S (optional)}

\item{delta}{parameter that inflates original polytope(simplex) fit such that it may contain more points of the dataset}

\item{verbose}{if TRUE display messages}

\item{conv_crit}{The convergence criteria (default: 10^-6 relative change in SSE)}

\item{maxiter}{maximum number of iterations (default: 500 iterations)}

\item{check_installed}{if TRUE, check if python module py_pcha is found. Useful to set to FALSE for running analysis or within other functions}

\item{order_by}{integer, dimensions to be used for ordering vertices/archetypes. Vertices are ordered by angle (cosine) between c(1, 1) vector and a vector pointing to that vertex. Additional step finds when vertex vector is to the left (counter-clockwise) of the c(1, 1) vector.}

\item{order_by_side}{used for ordering. If TRUE use 2 dimentions, cosine distance to c(1,1) and measure to which side of the c(1,1) vector each vertex vector is located. If FALSE use more than 2 dimentions (provided via order_by) and use cosine distance to c(1,1, ..., 1) to order vertices.}

\item{ks}{integer vector, dimensions of polytopes to be fit to data}

\item{n}{number of samples that should be taken}

\item{sample_prop}{either NULL or the proportion of dataset that should be included in each sample. If NULL the polytope fitting algorithm is run n times on the same data which is useful for evaluating how often the algorithm gets stuck in local optima. Not used when sample_type is "rand_shape".}

\item{type}{one of s, m, cmq. s means single core processing using lapply. m means multi-core parallel procession using parLapply. cmq means multi-node parallel processing on a computing cluster using clustermq package. "See also" for details.}

\item{clust_options}{list of options for parallel processing. The default for "m" is list(cores = parallel::detectCores()-1, cluster_type = "PSOCK"). The default for "cmq" is list(memory = 2000, template = list(), n_jobs = 10, fail_on_error = FALSE). Change these options as required.}

\item{seed}{seed for reproducible random number generation. Works for all types of processing.}

\item{replace}{should resampling be with replacement? passed to \link[base]{sample.int}}

\item{sample_type}{resample the data as is ("resample") or disrupt the relationships between variables keeping the distribution of each variable constant ("rand_shape")?}

\item{i}{iteration number}

\item{prob}{a vector of probability weights for obtaining the elements of the vector being sampled. Passed to \code{\link[base]{(sample.int}}.}

\item{bootstrap_N}{integer, number of bootstrap samples on random data to measure variability in vertex positions. When this option is chosen bootstrap_seed and sample_prop must be provided}

\item{bootstrap_seed}{seed for random number generation in bootstraping}

\item{return_data}{return randomised data?}

\item{return_arc}{return archetype positions in randomised data?}
}
\value{
\code{fit_pch()} object of class pch_fit (list) containing the following elements:
XC - numeric matrix, dim(I, noc)/dim(dimensions, archetypes) feature matrix (i.e. XC=data[,I]*C forming the archetypes);
S - numeric matrix, dim(noc, length(U)) matrix, S>=0 |S_j|_1=1;
C - numeric matrix, dim(noc, length(U)) matrix, S>=0 |S_j|_1=1;
SSE - numeric vector (1L), Sum of Squared Errors;
varexpl - numeric vector (1L), Percent variation explained by the model.

\code{k_fit_pch()} object of class k_pch_fit (list) containing XC (list of length(ks), individual XC matrices), S (list of length(ks), individual S matrices),  C (list of length(ks), individual C matrices), SSE (vector, length(ks)); varexpl - (vector, length(ks)). When length(ks) = 1 returns pch_fit.

\code{fit_pch_bootstrap()} object of class b_pch_fit (list) containing XC (list of length n, individual XC matrices), S (list of length n, individual S matrices),  C (list of length n, individual C matrices), SSE (vector, length n); varexpl - (vector, length n).

\code{fit_pch_resample()} object of class pch_fit (list)

\code{randomise_fit_pch1()} object of class pch_fit (list)
}
\description{
\code{fit_pch()} fits a polytope (Principal Convex Hull) to data using PCHA algorithm. All of the listed functions take input matrix dim(variables/dimentions, examples) and return output (XC) of dim(variables/dimentions, archetypes).

\code{k_fit_pch()} finds polytopes of k dimensions in the data. This function applies \code{fit_pch()} to different k-s.

\code{fit_pch_bootstrap()} Uses bootstrapping (resampling with) the data to find robust positions of vertices of a polytope (Principal Convex Hull) to data. This function uses \code{fit_pch_resample()}.

\code{fit_pch_resample()} takes one sample of the data and fits a polytope (Principal Convex Hull) to data. This function uses \code{fit_pch()}.

\code{randomise_fit_pch1()} helps answer the question "how likely you are to obtain the observed shape of the data given no relationship between variables?" disrupts the relationships between variables (one sample of the data), keeping the distribution of each variable constant, and fits a polytope (Principal Convex Hull) to data. This function uses \code{\link[ParetoTI]{rand_var}} and \code{fit_pch()}.
}
\details{
\code{fit_pch()} provides an R interface to python implementation of PCHA algorithm (Principal Convex Hull Analysis) by Ulf Aslak (https://github.com/ulfaslak/py_pcha) which was originally developed for Archetypal Analysis by MÃ¸rup et. al.
}
\examples{
set.seed(4355)
archetypes = generate_arc(arc_coord = list(c(5, 0), c(-10, 15), c(-30, -20)),
                          mean = 0, sd = 1, N_dim = 2)
data = generate_data(archetypes, N_examples = 1e4, jiiter = 0.04, size = 0.9)
dim(data)
# Fit a polytope with 3 vertices to data matrix
arc = fit_pch(data, noc=as.integer(3), delta=0.1)
# Fit the same polytope 3 times without resampling to test convergence of the algorithm.
arc_rob = fit_pch_bootstrap(data, n = 3, sample_prop = NULL,
                         noc=as.integer(3), delta=0.1)
# Fit the 10 polytopes to resampled datasets each time looking at 70\% of examples.
arc_data = fit_pch_bootstrap(data, n = 10, sample_prop = 0.7,
                         noc=as.integer(3), delta=0.1)

# Use local parallel processing to fit the 10 polytopes to resampled datasets each time looking at 70\% of examples.
arc_data = fit_pch_bootstrap(data, n = 10, sample_prop = 0.7,
                         noc=as.integer(3), delta=0.1, type = "m")

# Fit polytopes with 2-4 vertices
arc_ks = k_fit_pch(data, ks = 2:4, check_installed = T, delta=0.1)
}
\seealso{
\code{\link[parallel]{parLapply}}, \code{\link[base]{lapply}}, \code{\link[clustermq]{Q}}
}
\author{
Vitalii Kleshchevnikov
}
